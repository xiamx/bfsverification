<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>// Place global declarations here.
bool hasRunning = false;
const int N = 2; //number of tasks
typedef int [-1, N - 1] pid_t;
const int RR_INTERVAL = 4;
clock t;
bool initialized = false;

chan runnable, run, timeout, done;

/* number of static REALTIME runqueues. BFS has this at 100.
 * for simulation purposes, we set it to be small.
 */
const int static_rq_count = 1;
typedef int [0, static_rq_count - 1] static_rq_n;
const int static_rq_size = N;

// nice level
typedef int [-1, 1] nice_t;
typedef int [0, static_rq_count] realtime_t;


typedef struct {
    pid_t pid;
    bool ready;
    nice_t nice;
    int required_computation_time;
    bool realtime;
    realtime_t realtime_priority;
    bool completed;
} task_t; 

// 2-D array of static runqueues
task_t static_rq[static_rq_n][static_rq_size]; 
// record the lenght of each static_rq
int static_rq_len[static_rq_n];

// normal runqueue
task_t normal_rq[N];
// record the length of the normal runqueue
int normal_rq_len[N];

const task_t tasks[N] = {
    { 0, false, 0, 1, true, 0, false}, // a non cpu intensive task
    { 1, false, 0, 11, true, 0, false} // a cpu intensive task
    //{ 2, false, 0, 32767, 0,  0,  true, 0} // a realtime task that can starve the system
};


void add (task_t task){
    if (task.completed) {
        // if completed, reset
        task.completed = false;
    }
    // is it a realtime ?
    if (task.realtime) {
        int rqlen = static_rq_len[task.realtime_priority];
        static_rq[task.realtime_priority][rqlen] = task;
        static_rq_len[task.realtime_priority]++;
    } else {
        // then this must be a sched_normal

    }
}

void initialize() {
    for (i: static_rq_n) static_rq_len[i] = 0;
    for (i: static_rq_n) for (j: int[0,N - 1]) static_rq[i][j].pid = -1;
    for (i: int[0, N-1]) add(tasks[i]);
    initialized = true;
}
</declaration>
	<template>
		<name x="5" y="5">Process</name>
		<parameter>const int[0, N-1] p</parameter>
		<declaration>// Place local declarations here.
clock ax, idlex;

task_t task = tasks[p];

bool lastIterationIsCompletion = false;

int iterations;

void updateClocks() {
    if (lastIterationIsCompletion) {
        ax = 0;
        idlex = 0;
    }
}

void updateRunQueues() {
    if (task.realtime) {
        // remove head of the corresponding static_runqueue
        pid_t i;
        int rqlen = static_rq_len[task.realtime_priority];
        for (i = 0; i&lt; rqlen - 1; i++) {
            static_rq[task.realtime_priority][i] = static_rq[task.realtime_priority][i + 1];
        }
        static_rq[task.realtime_priority][rqlen - 1].pid = -1;
        //decrease static_rq_len by 1
        static_rq_len[task.realtime_priority]--;
    }
}

bool isNextToRun() {
    if (task.realtime) {
        int rqlen = static_rq_len[task.realtime_priority];
        return static_rq[task.realtime_priority][0].pid == task.pid;
    } else {
        return false;
    }
}

// Given a nice level. Get the corresponding RR_interval
int getRRInterval(int[-1,1] nice) {
    if (nice == -1) {
        return RR_INTERVAL/2;
    } else if (nice == 0) {
        return RR_INTERVAL;
    } else {
        return RR_INTERVAL*2;
    }
}

</declaration>
		<location id="id0" x="-42" y="263">
			<name x="-52" y="229">Completed</name>
		</location>
		<location id="id1" x="-34" y="-68">
			<name x="-44" y="-102">Added</name>
		</location>
		<location id="id2" x="-42" y="161">
			<name x="-42" y="178">Running</name>
		</location>
		<location id="id3" x="-127" y="17">
			<name x="-101" y="9">Runnable</name>
			<committed/>
		</location>
		<location id="id4" x="-34" y="-170">
			<name x="-44" y="-204">Idle</name>
			<committed/>
		</location>
		<init ref="id1"/>
		<transition>
			<source ref="id0"/>
			<target ref="id4"/>
			<label kind="synchronisation" x="-24" y="246">timeout?</label>
			<label kind="assignment" x="-25" y="263">ax = 0,
lastIterationIsCompletion = true</label>
			<nail x="170" y="263"/>
			<nail x="323" y="263"/>
			<nail x="323" y="-238"/>
			<nail x="-34" y="-238"/>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id0"/>
			<label kind="guard" x="-34" y="187">ax == task.required_computation_time</label>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id1"/>
			<label kind="guard" x="-127" y="-127">initialized</label>
			<label kind="assignment" x="-17" y="-119">add(tasks[p]),
idlex = 0</label>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id3"/>
			<label kind="guard" x="-170" y="-76">isNextToRun() &amp;&amp;
!hasRunning</label>
			<label kind="synchronisation" x="-161" y="-34">runnable!</label>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id4"/>
			<label kind="guard" x="8" y="136">ax  &lt; task.required_computation_time</label>
			<label kind="synchronisation" x="178" y="8">timeout?</label>
			<nail x="170" y="161"/>
			<nail x="169" y="-170"/>
			<nail x="-8" y="-170"/>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id2"/>
			<label kind="synchronisation" x="-25" y="25">run?</label>
			<label kind="assignment" x="-25" y="42">updateRunQueues(),
hasRunning = true,
updateClocks()</label>
		</transition>
	</template>
	<template>
		<name>BFS</name>
		<declaration>bool isRunQueuesEmpty() {
    return forall (i: static_rq_n) static_rq_len[i] == 0;
}

void updateQueues () {

}</declaration>
		<location id="id5" x="-144" y="-442">
			<name x="-154" y="-476">scheduled</name>
			<label kind="invariant" x="-93" y="-450">t &lt;= RR_INTERVAL</label>
		</location>
		<location id="id6" x="51" y="-238">
			<name x="41" y="-272">schedulable</name>
			<committed/>
		</location>
		<location id="id7" x="-178" y="-17">
			<name x="-229" y="0">runQueueEmpty</name>
		</location>
		<location id="id8" x="-306" y="-238">
			<name x="-316" y="-272">idle</name>
			<committed/>
		</location>
		<location id="id9" x="-408" y="-238">
			<name x="-418" y="-272">Init</name>
			<committed/>
		</location>
		<init ref="id9"/>
		<transition>
			<source ref="id5"/>
			<target ref="id8"/>
			<label kind="guard" x="-297" y="-476">t == RR_INTERVAL</label>
			<label kind="synchronisation" x="-297" y="-450">timeout!</label>
			<label kind="assignment" x="-297" y="-425">hasRunning = false</label>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id5"/>
			<label kind="synchronisation" x="-59" y="-382">run!</label>
			<label kind="assignment" x="-17" y="-382">t = 0</label>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id6"/>
			<label kind="synchronisation" x="-85" y="-102">runnable?</label>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id6"/>
			<label kind="guard" x="-221" y="-238">!isRunQueuesEmpty()</label>
			<label kind="synchronisation" x="-288" y="-255">runnable?</label>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id7"/>
			<label kind="guard" x="-408" y="-161">isRunQueuesEmpty()</label>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id8"/>
			<label kind="assignment" x="-390" y="-238">initialize()</label>
		</transition>
	</template>
	<system>system BFS, Process;
gantt {
  Task(i : int[0, N-1]): Process(i).Idle -&gt; 1,
                   Process(i).Added -&gt; 2,
                   Process(i).Runnable -&gt; 3,
                   Process(i).Running -&gt; 4,
                   Process(i).Idle -&gt; 5;
}
</system>
	<queries>
		<query>
			<formula>Process(1).Running --&gt; Process(1).Idle
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>Process(0).Added --&gt; Process(0).Running
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>A[] not deadlock
			</formula>
			<comment>System will not deadlock
			</comment>
		</query>
	</queries>
</nta>
